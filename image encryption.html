<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberEncrypt Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --neon-purple: #b026ff;
            --neon-blue: #0892d0;
            --neon-green: #39ff14;
            --neon-pink: #ff2a6d;
            --neon-cyan: #05ffa1;
        }
        
        body {
            background-color: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
        }
        
        .cyberpunk-bg {
            background-color: rgba(10, 10, 15, 0.8);
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(17, 38, 70, 0.2) 0%, transparent 40%),
                radial-gradient(circle at 85% 30%, rgba(75, 10, 120, 0.2) 0%, transparent 50%),
                linear-gradient(0deg, transparent 0%, rgba(5, 5, 10, 0.8) 100%);
            background-size: cover;
            position: relative;
        }
        
        .cyberpunk-bg::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, rgba(15, 15, 35, 0.1), rgba(15, 15, 35, 0.1) 1px, transparent 1px, transparent 2px),
                repeating-linear-gradient(90deg, rgba(15, 15, 35, 0.1), rgba(15, 15, 35, 0.1) 1px, transparent 1px, transparent 2px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: -1;
        }
        
        .glitch-text {
            position: relative;
            text-shadow: 
                0 0 5px var(--neon-blue),
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue);
            animation: glitch 5s infinite;
        }
        
        @keyframes glitch {
            0% { 
                text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
                transform: translateX(0);
            }
            2% { 
                text-shadow: 0 0 5px var(--neon-pink), 0 0 10px var(--neon-pink);
                transform: translateX(-2px);
            }
            4% { 
                text-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green);
                transform: translateX(2px);
            }
            6% { 
                text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
                transform: translateX(0);
            }
            98% {
                text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
                transform: translateX(0);
            }
            100% {
                text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
                transform: translateX(0);
            }
        }
        
        .terminal {
            background-color: rgba(5, 5, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue), inset 0 0 10px rgba(8, 146, 208, 0.3);
            padding: 10px;
            font-family: "Courier New", monospace;
            color: #00ff00;
            overflow: hidden;
            position: relative;
        }
        
        .terminal::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: scanline 3s linear infinite;
        }
        
        @keyframes scanline {
            0% { transform: translateY(-5px); opacity: 0.5; }
            50% { transform: translateY(250px); opacity: 0.7; }
            100% { transform: translateY(500px); opacity: 0.5; }
        }
        
        .hex-display {
            font-family: monospace;
            color: var(--neon-green);
            font-size: 0.8rem;
            line-height: 1.2;
            white-space: pre-wrap;
            overflow: hidden;
        }
        
        .rain-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
            opacity: 0.3;
        }
        
        .neon-button {
            background-color: rgba(5, 15, 35, 0.7);
            color: var(--neon-cyan);
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 5px var(--neon-cyan);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .neon-button:hover {
            background-color: rgba(5, 255, 161, 0.2);
            box-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
        }
        
        .neon-button:active {
            transform: scale(0.98);
        }
        
        .download-button {
            background-color: rgba(5, 15, 35, 0.7);
            color: var(--neon-purple);
            border: 1px solid var(--neon-purple);
            box-shadow: 0 0 5px var(--neon-purple), 0 0 10px var(--neon-purple);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none;
            position: relative;
            overflow: hidden;
            animation: pulse-download 2s infinite;
            transform: scale(1);
        }
        
        @keyframes pulse-download {
            0% {
                transform: scale(1);
                box-shadow: 0 0 5px var(--neon-purple), 0 0 10px var(--neon-purple);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px var(--neon-purple), 0 0 20px var(--neon-purple), 0 0 30px var(--neon-purple);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 5px var(--neon-purple), 0 0 10px var(--neon-purple);
            }
        }
        
        .download-button:hover {
            background-color: rgba(176, 38, 255, 0.3);
            box-shadow: 0 0 15px var(--neon-purple), 0 0 25px var(--neon-purple);
            transform: scale(1.02);
        }
        
        .download-button:active {
            transform: scale(0.98);
        }
        
        .download-button::before {
            content: "";
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, 
                var(--neon-purple) 0%, 
                transparent 20%,
                transparent 40%,
                var(--neon-blue) 50%,
                transparent 60%,
                transparent 80%,
                var(--neon-purple) 100%);
            opacity: 0.5;
            z-index: -1;
            animation: rotate-download 3s linear infinite;
        }
        
        @keyframes rotate-download {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background-color: rgba(5, 5, 15, 0.7);
            border: 1px solid var(--neon-blue);
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
            position: relative;
            transition: width 0.2s;
        }
        
        .progress-bar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                transparent 100%);
            animation: progress-glow 2s linear infinite;
        }
        
        @keyframes progress-glow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .panel {
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px rgba(8, 146, 208, 0.5);
            background-color: rgba(5, 5, 15, 0.8);
            position: relative;
            overflow: hidden;
        }
        
        .panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            animation: panel-glow 3s ease-in-out infinite;
        }
        
        @keyframes panel-glow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .panel-header {
            border-bottom: 1px solid var(--neon-blue);
            padding: 5px 10px;
            font-size: 0.9rem;
            color: var(--neon-blue);
            background-color: rgba(8, 146, 208, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-header::before {
            content: "◉";
            color: var(--neon-green);
            margin-right: 5px;
        }
        
        .panel-header::after {
            content: "[ACTIVE]";
            font-size: 0.7rem;
            color: var(--neon-green);
            margin-left: auto;
        }
        
        .packet {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--neon-green);
            opacity: 0.8;
        }
        
        .key-segment {
            display: inline-block;
            padding: 2px 4px;
            margin: 2px;
            background-color: rgba(57, 255, 20, 0.1);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            font-family: monospace;
            font-size: 0.7rem;
        }
        
        .visual-block {
            width: 10px;
            height: 10px;
            display: inline-block;
            margin: 1px;
            opacity: 0.8;
            transition: all 0.2s;
        }
        
        .byte-display {
            font-family: monospace;
            font-size: 0.5rem;
            color: var(--neon-cyan);
            display: flex;
            flex-wrap: wrap;
        }
        
        .byte-cell {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(5, 255, 161, 0.3);
            margin: 1px;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .flicker {
            animation: flicker 2s linear infinite;
        }
        
        @keyframes flicker {
            0% { opacity: 1; }
            49% { opacity: 1; }
            50% { opacity: 0.8; }
            51% { opacity: 1; }
            59% { opacity: 1; }
            60% { opacity: 0.7; }
            61% { opacity: 1; }
            100% { opacity: 1; }
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #matrixCanvas, #networkCanvas, #encryptCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #encryptCanvas {
            opacity: 0.8;
        }
        
        .thumbnail-container {
            width: 100%;
            height: 150px;
            position: relative;
            overflow: hidden;
            background-color: rgba(5, 5, 15, 0.7);
            border: 1px solid var(--neon-blue);
        }
        
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                45deg, 
                transparent 0%, 
                rgba(176, 38, 255, 0.1) 20%, 
                transparent 40%,
                rgba(8, 146, 208, 0.1) 60%,
                transparent 80%,
                rgba(57, 255, 20, 0.1) 100%
            );
            pointer-events: none;
            animation: glitch-sweep 5s linear infinite;
        }
        
        @keyframes glitch-sweep {
            0% { transform: translateX(-100%) skewX(-20deg); }
            100% { transform: translateX(100%) skewX(-20deg); }
        }
        
        .console-input {
            background-color: rgba(5, 5, 15, 0.8);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            font-family: 'Courier New', monospace;
            padding: 5px 10px;
            width: 100%;
        }
        
        .console-input:focus {
            outline: none;
            box-shadow: 0 0 5px var(--neon-green);
        }
        
        .typing::after {
            content: "|";
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        .noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.05;
            z-index: 9999;
            background-image: url('https://cdn.jsdelivr.net/gh/patrickkunka/mixitup@master/demos/assets/noise.png');
            animation: noise-animation 0.5s linear infinite;
        }
        
        @keyframes noise-animation {
            0% { transform: translate(0, 0); }
            10% { transform: translate(-1%, -1%); }
            20% { transform: translate(1%, 1%); }
            30% { transform: translate(-2%, -2%); }
            40% { transform: translate(2%, 2%); }
            50% { transform: translate(-1%, -1%); }
            60% { transform: translate(1%, 1%); }
            70% { transform: translate(-2%, -2%); }
            80% { transform: translate(2%, 2%); }
            90% { transform: translate(-1%, -1%); }
            100% { transform: translate(0, 0); }
        }

        .blinking-cursor {
            animation: blink 1s step-end infinite;
        }

        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(57, 255, 20, 0.2);
            opacity: 0.7;
            z-index: 999;
            pointer-events: none;
            animation: scan 5s linear infinite;
        }

        @keyframes scan {
            0% { top: -5%; }
            100% { top: 105%; }
        }
        
        .success-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 0%, rgba(176, 38, 255, 0.1) 50%, transparent 100%);
            z-index: 9990;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .success-animation.active {
            animation: success-pulse 0.8s ease-out;
        }
        
        @keyframes success-pulse {
            0% { opacity: 0; transform: scale(0); }
            50% { opacity: 0.7; }
            100% { opacity: 0; transform: scale(2); }
        }
    </style>
</head>
<body class="cyberpunk-bg min-h-screen">
    <div class="noise"></div>
    <div class="scanline"></div>
    <div class="success-animation" id="success-animation"></div>
    
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold glitch-text mb-2 tracking-wider text-center">
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-blue-500 to-green-400">CYBER</span>
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 via-blue-500 to-purple-400">ENCRYPT</span>
            </h1>
            <p class="text-gray-400 mt-2 flicker">ADVANCED IMAGE ENCRYPTION & SECURITY SYSTEM</p>
            <div class="flex justify-center items-center mt-4">
                <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse mr-2"></div>
                <span class="text-xs text-green-500">SYSTEM ACTIVE</span>
                <div class="mx-4 text-gray-600">|</div>
                <div id="system-status" class="text-xs text-blue-400">READY</div>
                <div class="mx-4 text-gray-600">|</div>
                <div id="current-time" class="text-xs text-purple-400">00:00:00</div>
            </div>
        </header>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="panel col-span-1 md:col-span-2">
                <div class="panel-header">SECURITY MATRIX</div>
                <div class="canvas-container h-48">
                    <canvas id="matrixCanvas"></canvas>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">SYSTEM STATUS</div>
                <div class="p-4">
                    <div class="flex justify-between mb-2">
                        <span class="text-xs text-blue-400">ENCRYPTION CORE:</span>
                        <span class="text-xs text-green-500">ONLINE</span>
                    </div>
                    <div class="flex justify-between mb-2">
                        <span class="text-xs text-blue-400">NETWORK:</span>
                        <span class="text-xs text-green-500">SECURE</span>
                    </div>
                    <div class="flex justify-between mb-2">
                        <span class="text-xs text-blue-400">FIREWALL:</span>
                        <span class="text-xs text-green-500">ACTIVE</span>
                    </div>
                    <div class="flex justify-between mb-2">
                        <span class="text-xs text-blue-400">INTRUSION DETECTION:</span>
                        <span class="text-xs text-yellow-500">MONITORING</span>
                    </div>
                    <div id="cpu-usage" class="mt-4">
                        <div class="flex justify-between">
                            <span class="text-xs text-blue-400">CPU USAGE:</span>
                            <span id="cpu-percent" class="text-xs text-green-500">12%</span>
                        </div>
                        <div class="progress-container mt-1">
                            <div id="cpu-bar" class="progress-bar" style="width: 12%"></div>
                        </div>
                    </div>
                    <div id="memory-usage" class="mt-4">
                        <div class="flex justify-between">
                            <span class="text-xs text-blue-400">MEMORY:</span>
                            <span id="memory-percent" class="text-xs text-green-500">34%</span>
                        </div>
                        <div class="progress-container mt-1">
                            <div id="memory-bar" class="progress-bar" style="width: 34%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="panel">
                <div class="panel-header">IMAGE PROCESSOR</div>
                <div class="p-4">
                    <div class="thumbnail-container mb-4 flex justify-center items-center" id="image-preview">
                        <div class="text-gray-500 text-sm">No image selected</div>
                        <div class="glitch-overlay"></div>
                    </div>
                    
                    <label class="neon-button py-2 px-4 w-full block text-center cursor-pointer mb-2">
                        <input type="file" id="image-upload" class="hidden" accept="image/*">
                        SELECT IMAGE
                    </label>
                    
                    <button id="encrypt-btn" class="neon-button py-2 px-4 w-full block text-center mb-2 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        ENCRYPT
                    </button>
                    
                    <button id="decrypt-btn" class="neon-button py-2 px-4 w-full block text-center mb-2 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        DECRYPT
                    </button>
                    
                    <button id="download-btn" class="download-button py-2 px-4 w-full block text-center" style="display: none;">
                        <i class="fas fa-download mr-2"></i>DOWNLOAD IMAGE
                    </button>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">ENCRYPTION PROCESS</div>
                <div class="p-4">
                    <div id="encryption-status" class="text-sm text-blue-400 mb-2">WAITING FOR IMAGE</div>
                    
                    <div id="encryption-progress" class="mb-4">
                        <div class="flex justify-between text-xs mb-1">
                            <span>PROGRESS:</span>
                            <span id="progress-percent">0%</span>
                        </div>
                        <div class="progress-container">
                            <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="text-xs text-blue-400 mb-1">ENCRYPTION KEY:</div>
                        <div id="encryption-key" class="flex flex-wrap"></div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="text-xs text-blue-400 mb-1">ALGORITHM:</div>
                        <div id="algorithm-info" class="text-xs text-green-500">AES-256-CBC</div>
                    </div>
                    
                    <div class="canvas-container h-32 mb-2">
                        <canvas id="encryptCanvas"></canvas>
                        <div class="absolute inset-0 flex items-center justify-center" id="encryption-overlay">
                            <div class="text-sm text-gray-500">Visualization will appear during encryption</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">NETWORK ANALYSIS</div>
                <div class="canvas-container h-64">
                    <canvas id="networkCanvas"></canvas>
                </div>
                <div class="p-2 border-t border-blue-800">
                    <div class="text-xs text-blue-400">PACKET ANALYSIS:</div>
                    <div id="packet-log" class="text-xs text-green-500 h-24 overflow-y-auto"></div>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="panel">
                <div class="panel-header">HEX DUMP</div>
                <div class="p-2">
                    <div id="hex-display" class="hex-display h-48 overflow-y-auto overflow-x-hidden"></div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">SYSTEM CONSOLE</div>
                <div class="terminal h-48 overflow-y-auto p-2" id="console-output">
                    <div>CYBERENCRYPT v3.5.2 [BUILD 20240416]</div>
                    <div>> System initialized</div>
                    <div>> Encryption modules loaded</div>
                    <div>> Awaiting input...</div>
                </div>
                <div class="border-t border-blue-800 p-2">
                    <input type="text" id="console-input" class="console-input" placeholder="Enter command..." />
                </div>
            </div>
        </div>
        
        <div class="panel mb-6">
            <div class="panel-header">DATA VISUALIZATION</div>
            <div class="p-4">
                <div id="data-visualization" class="grid grid-cols-12 gap-1 h-40 overflow-hidden"></div>
            </div>
        </div>
        
        <footer class="text-center text-gray-500 text-xs mt-8 mb-4">
            <div class="flex justify-center items-center">
                <div class="w-1 h-1 bg-blue-500 rounded-full animate-pulse mr-1"></div>
                <span>SECURE SYSTEM</span>
                <div class="mx-2">|</div>
                <span>AES-256 ENCRYPTION</span>
                <div class="mx-2">|</div>
                <span>QUANTUM-RESISTANT PROTOCOLS</span>
            </div>
        </footer>
    </div>

    <script>
        // Utility functions
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function randomHex(length = 2) {
            const chars = '0123456789ABCDEF';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars[Math.floor(Math.random() * chars.length)];
            }
            return result;
        }
        
        // Update system time
        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        setInterval(updateTime, 1000);
        updateTime();
        
        // Matrix rain effect
        function setupMatrixRain() {
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match container
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん'.split('');
            const columns = Math.floor(canvas.width / 15);
            const drops = [];
            
            // Initialize drops
            for (let i = 0; i < columns; i++) {
                drops[i] = randomInt(-100, 0);
            }
            
            // Draw matrix rain
            function drawMatrixRain() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0f0';
                ctx.font = '15px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    
                    // Bright head characters
                    if (drops[i] >= 0) {
                        ctx.fillStyle = '#8f8';
                        ctx.fillText(text, i * 15, drops[i] * 15);
                        ctx.fillStyle = '#0f0';
                    }
                    
                    if (drops[i] >= 0) drops[i]++;
                    
                    // Reset drop to top with random delay
                    if (drops[i] * 15 > canvas.height && Math.random() > 0.99) {
                        drops[i] = 0;
                    }
                    
                    // Generate new drop
                    if (drops[i] < 0) drops[i]++;
                }
                
                requestAnimationFrame(drawMatrixRain);
            }
            
            drawMatrixRain();
        }
        
        // Network visualization
        function setupNetworkVisualization() {
            const canvas = document.getElementById('networkCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match container
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Create nodes
            const nodes = [];
            const nodeCount = 12;
            
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 3 + Math.random() * 2,
                    color: i % 3 === 0 ? '#39ff14' : i % 3 === 1 ? '#0892d0' : '#b026ff',
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            }
            
            // Create connections between nodes
            const connections = [];
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (Math.random() > 0.6) {
                        connections.push({
                            from: i,
                            to: j,
                            active: false,
                            lastActive: 0
                        });
                    }
                }
            }
            
            // Create packets
            const packets = [];
            
            function createPacket() {
                if (connections.length === 0) return;
                
                const connection = connections[Math.floor(Math.random() * connections.length)];
                const fromNode = nodes[connection.from];
                const toNode = nodes[connection.to];
                
                packets.push({
                    x: fromNode.x,
                    y: fromNode.y,
                    targetX: toNode.x,
                    targetY: toNode.y,
                    fromNode: connection.from,
                    toNode: connection.to,
                    speed: 1 + Math.random(),
                    size: 2 + Math.random() * 2,
                    color: Math.random() > 0.5 ? '#39ff14' : '#0892d0',
                    progress: 0
                });
                
                connection.active = true;
                connection.lastActive = Date.now();
                
                // Log packet activity
                const packetLog = document.getElementById('packet-log');
                const logEntry = document.createElement('div');
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] Packet transfer: Node${connection.from} → Node${connection.to} | ${randomHex(4)}:${randomHex(4)}`;
                packetLog.prepend(logEntry);
                
                // Keep only the last 20 log entries
                while (packetLog.children.length > 20) {
                    packetLog.removeChild(packetLog.lastChild);
                }
            }
            
            // Create packet every 500-1500ms
            function schedulePacketCreation() {
                createPacket();
                setTimeout(schedulePacketCreation, 500 + Math.random() * 1000);
            }
            
            schedulePacketCreation();
            
            // Animation
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections
                connections.forEach(conn => {
                    const fromNode = nodes[conn.from];
                    const toNode = nodes[conn.to];
                    
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    
                    if (conn.active && Date.now() - conn.lastActive < 500) {
                        ctx.strokeStyle = 'rgba(57, 255, 20, 0.8)';
                        ctx.lineWidth = 1.5;
                    } else {
                        ctx.strokeStyle = 'rgba(8, 146, 208, 0.3)';
                        ctx.lineWidth = 0.5;
                    }
                    
                    ctx.stroke();
                    
                    if (Date.now() - conn.lastActive > 500) {
                        conn.active = false;
                    }
                });
                
                // Draw nodes
                nodes.forEach(node => {
                    // Update position
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Bounce off edges
                    if (node.x < node.radius || node.x > canvas.width - node.radius) node.vx *= -1;
                    if (node.y < node.radius || node.y > canvas.height - node.radius) node.vy *= -1;
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = node.color;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius + 3, 0, Math.PI * 2);
                    ctx.strokeStyle = `${node.color}44`;
                    ctx.stroke();
                });
                
                // Update and draw packets
                for (let i = packets.length - 1; i >= 0; i--) {
                    const packet = packets[i];
                    
                    // Update position
                    packet.progress += 0.01 * packet.speed;
                    
                    if (packet.progress >= 1) {
                        // Remove packet
                        packets.splice(i, 1);
                        continue;
                    }
                    
                    packet.x = nodes[packet.fromNode].x + (nodes[packet.toNode].x - nodes[packet.fromNode].x) * packet.progress;
                    packet.y = nodes[packet.fromNode].y + (nodes[packet.toNode].y - nodes[packet.fromNode].y) * packet.progress;
                    
                    // Draw packet
                    ctx.beginPath();
                    ctx.arc(packet.x, packet.y, packet.size, 0, Math.PI * 2);
                    ctx.fillStyle = packet.color;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(packet.x, packet.y, packet.size + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = `${packet.color}44`;
                    ctx.stroke();
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Encryption visualization
        function setupEncryptionVisualization() {
            const canvas = document.getElementById('encryptCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match container
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            let isEncrypting = false;
            let blocks = [];
            const blockSize = 6;
            const gridWidth = Math.floor(canvas.width / blockSize);
            const gridHeight = Math.floor(canvas.height / blockSize);
            
            // Initialize blocks
            function initBlocks() {
                blocks = [];
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        blocks.push({
                            x: x * blockSize,
                            y: y * blockSize,
                            width: blockSize,
                            height: blockSize,
                            original: Math.random() > 0.5,
                            encrypted: false,
                            color: `hsl(${Math.random() * 60 + 120}, 100%, 50%)`,
                            encryptedColor: `hsl(${Math.random() * 60 + 270}, 100%, 50%)`
                        });
                    }
                }
            }
            
            initBlocks();
            
            // Animation
            function drawEncryption() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                blocks.forEach(block => {
                    if (block.encrypted) {
                        ctx.fillStyle = block.encryptedColor;
                    } else if (block.original) {
                        ctx.fillStyle = block.color;
                    } else {
                        ctx.fillStyle = '#111';
                    }
                    
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                });
                
                if (isEncrypting) {
                    // Encrypt/decrypt more blocks
                    for (let i = 0; i < 10; i++) {
                        const index = Math.floor(Math.random() * blocks.length);
                        blocks[index].encrypted = !blocks[index].encrypted;
                    }
                }
                
                requestAnimationFrame(drawEncryption);
            }
            
            drawEncryption();
            
            // Export control functions
            window.encryptionVis = {
                startEncryption: () => {
                    isEncrypting = true;
                    document.getElementById('encryption-overlay').style.display = 'none';
                },
                stopEncryption: () => {
                    isEncrypting = false;
                    setTimeout(() => {
                        blocks.forEach(block => {
                            block.encrypted = false;
                        });
                    }, 500);
                },
                resetCanvas: initBlocks
            };
        }
        
        // Data visualization
        function setupDataVisualization() {
            const container = document.getElementById('data-visualization');
            const totalCells = 12 * 20; // Based on grid-cols-12
            
            // Create cells
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'visual-block bg-blue-900';
                container.appendChild(cell);
            }
            
            // Randomly update cells
            function updateCells() {
                const cells = container.querySelectorAll('.visual-block');
                
                cells.forEach(cell => {
                    if (Math.random() > 0.7) {
                        const hue = Math.random() > 0.5 ? 
                            Math.floor(Math.random() * 60 + 120) : // Green/cyan range
                            Math.floor(Math.random() * 60 + 270);  // Purple/pink range
                        
                        cell.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                        cell.style.boxShadow = `0 0 5px hsl(${hue}, 100%, 50%)`;
                        
                        setTimeout(() => {
                            cell.style.backgroundColor = '';
                            cell.style.boxShadow = '';
                        }, 1000 + Math.random() * 2000);
                    }
                });
                
                setTimeout(updateCells, 100 + Math.random() * 200);
            }
            
            updateCells();
        }
        
        // Initialize hex display
        function initHexDisplay() {
            const hexDisplay = document.getElementById('hex-display');
            
            function generateHexDump() {
                let output = '';
                const rows = 20;
                
                for (let i = 0; i < rows; i++) {
                    // Address
                    const addr = (i * 16).toString(16).padStart(8, '0');
                    output += `${addr}  `;
                    
                    // Hex values
                    for (let j = 0; j < 16; j++) {
                        output += `${randomHex(2)} `;
                        if (j === 7) output += ' ';
                    }
                    
                    output += ' |';
                    
                    // ASCII representation
                    for (let j = 0; j < 16; j++) {
                        // Generate a random ASCII character (visible range)
                        const charCode = Math.floor(Math.random() * 94) + 33;
                        output += String.fromCharCode(charCode);
                    }
                    
                    output += '|\n';
                }
                
                hexDisplay.textContent = output;
            }
            
            // Update hex display periodically when encrypting
            window.hexDisplay = {
                start: () => {
                    window.hexInterval = setInterval(generateHexDump, 500);
                },
                stop: () => {
                    clearInterval(window.hexInterval);
                    hexDisplay.textContent = '';
                }
            };
        }
        
        // Console functionality
        function setupConsole() {
            const consoleInput = document.getElementById('console-input');
            const consoleOutput = document.getElementById('console-output');
            
            const commands = {
                help: () => {
                    appendToConsole('Available commands:');
                    appendToConsole('  help - Show this help');
                    appendToConsole('  clear - Clear console');
                    appendToConsole('  status - Show system status');
                    appendToConsole('  encrypt - Start encryption process');
                    appendToConsole('  decrypt - Start decryption process');
                    appendToConsole('  download - Download current image');
                    appendToConsole('  info - Show encryption info');
                },
                clear: () => {
                    consoleOutput.innerHTML = '';
                    appendToConsole('Console cleared.');
                },
                status: () => {
                    appendToConsole('System Status:');
                    appendToConsole('  Encryption Core: ONLINE');
                    appendToConsole('  Network Status: SECURE');
                    appendToConsole('  CPU Usage: ' + document.getElementById('cpu-percent').textContent);
                    appendToConsole('  Memory Usage: ' + document.getElementById('memory-percent').textContent);
                    appendToConsole('  AES Modules: LOADED');
                    appendToConsole('  Key Generator: READY');
                },
                encrypt: () => {
                    if (!window.originalImage) {
                        appendToConsole('Error: No image loaded');
                        return;
                    }
                    startEncryption();
                },
                decrypt: () => {
                    if (!window.encryptedImage) {
                        appendToConsole('Error: No encrypted image available');
                        return;
                    }
                    startDecryption();
                },
                download: () => {
                    downloadProcessedImage();
                },
                info: () => {
                    appendToConsole('Encryption Information:');
                    appendToConsole('  Algorithm: AES-256-CBC');
                    appendToConsole('  Key Size: 256 bits');
                    appendToConsole('  Block Size: 128 bits');
                    appendToConsole('  IV Size: 128 bits');
                    appendToConsole('  Padding: PKCS#7');
                    appendToConsole('  Mode: Cipher Block Chaining');
                }
            };
            
            function appendToConsole(text) {
                const line = document.createElement('div');
                
                if (!text.startsWith('>')) {
                    line.textContent = text;
                } else {
                    line.textContent = text;
                    line.classList.add('typing');
                }
                
                consoleOutput.appendChild(line);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
                
                // Remove typing class after a delay
                if (line.classList.contains('typing')) {
                    setTimeout(() => {
                        line.classList.remove('typing');
                    }, 500);
                }
            }
            
            consoleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const cmd = consoleInput.value.trim().toLowerCase();
                    appendToConsole(`> ${cmd}`);
                    
                    if (commands[cmd]) {
                        commands[cmd]();
                    } else if (cmd) {
                        appendToConsole(`Command not found: ${cmd}`);
                        appendToConsole('Type "help" for available commands');
                    }
                    
                    consoleInput.value = '';
                }
            });
        }
        
        // System resource simulation
        function setupResourceMonitoring() {
            const cpuBar = document.getElementById('cpu-bar');
            const cpuPercent = document.getElementById('cpu-percent');
            const memoryBar = document.getElementById('memory-bar');
            const memoryPercent = document.getElementById('memory-percent');
            
            function updateResources() {
                // Random CPU usage between 5% and 25%
                let cpuUsage = 5 + Math.random() * 20;
                
                // Random memory usage between 30% and 45%
                let memoryUsage = 30 + Math.random() * 15;
                
                // Increase when encrypting
                if (window.isEncrypting) {
                    cpuUsage += 50 + Math.random() * 20;
                    memoryUsage += 20 + Math.random() * 10;
                }
                
                // Update UI
                cpuBar.style.width = `${cpuUsage}%`;
                cpuPercent.textContent = `${Math.round(cpuUsage)}%`;
                
                memoryBar.style.width = `${memoryUsage}%`;
                memoryPercent.textContent = `${Math.round(memoryUsage)}%`;
                
                // Change color based on usage
                if (cpuUsage > 80) {
                    cpuBar.style.background = 'linear-gradient(90deg, var(--neon-purple), var(--neon-pink))';
                    cpuPercent.className = 'text-xs text-pink-500';
                } else if (cpuUsage > 50) {
                    cpuBar.style.background = 'linear-gradient(90deg, var(--neon-blue), var(--neon-purple))';
                    cpuPercent.className = 'text-xs text-yellow-500';
                } else {
                    cpuBar.style.background = 'linear-gradient(90deg, var(--neon-blue), var(--neon-purple))';
                    cpuPercent.className = 'text-xs text-green-500';
                }
                
                setTimeout(updateResources, 2000 + Math.random() * 1000);
            }
            
            updateResources();
        }
        
        // Key generation visualization
        function generateEncryptionKey() {
            const keyContainer = document.getElementById('encryption-key');
            keyContainer.innerHTML = '';
            
            // Generate key segments
            for (let i = 0; i < 8; i++) {
                const segment = document.createElement('div');
                segment.className = 'key-segment';
                segment.textContent = randomHex(8);
                keyContainer.appendChild(segment);
                
                // Animate segments appearing
                segment.style.opacity = '0';
                setTimeout(() => {
                    segment.style.opacity = '1';
                }, i * 100);
            }
        }
        
        // Image handling
        function setupImageHandling() {
            const imageUpload = document.getElementById('image-upload');
            const imagePreview = document.getElementById('image-preview');
            const encryptBtn = document.getElementById('encrypt-btn');
            const decryptBtn = document.getElementById('decrypt-btn');
            const downloadBtn = document.getElementById('download-btn');
            
            imageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        // Store original image
                        window.originalImage = img;
                        window.currentImageName = file.name || 'image';
                        
                        // Update preview
                        imagePreview.innerHTML = '';
                        const preview = document.createElement('img');
                        preview.src = event.target.result;
                        preview.className = 'max-h-full max-w-full object-contain';
                        imagePreview.appendChild(preview);
                        
                        // Add glitch overlay
                        const overlay = document.createElement('div');
                        overlay.className = 'glitch-overlay';
                        imagePreview.appendChild(overlay);
                        
                        // Enable encrypt button, disable decrypt
                        encryptBtn.disabled = false;
                        decryptBtn.disabled = true;
                        
                        // Hide download button
                        downloadBtn.style.display = 'none';
                        
                        // Update UI
                        const status = document.getElementById('encryption-status');
                        status.textContent = 'IMAGE LOADED - READY TO ENCRYPT';
                        status.className = 'text-sm text-green-500 mb-2';
                        
                        // Update system status
                        document.getElementById('system-status').textContent = 'IMAGE LOADED';
                        
                        // Log to console
                        const consoleOutput = document.getElementById('console-output');
                        const logEntry = document.createElement('div');
                        logEntry.textContent = `> Image loaded: ${file.name} (${Math.round(file.size / 1024)} KB)`;
                        consoleOutput.appendChild(logEntry);
                        consoleOutput.scrollTop = consoleOutput.scrollHeight;
                    };
                };
                reader.readAsDataURL(file);
            });
            
            encryptBtn.addEventListener('click', startEncryption);
            decryptBtn.addEventListener('click', startDecryption);
            downloadBtn.addEventListener('click', downloadProcessedImage);
        }
        
        // Encryption process
        function startEncryption() {
            if (!window.originalImage) return;
            
            window.isEncrypting = true;
            
            // Update UI
            const status = document.getElementById('encryption-status');
            status.textContent = 'ENCRYPTION IN PROGRESS';
            status.className = 'text-sm text-yellow-500 mb-2';
            
            document.getElementById('system-status').textContent = 'ENCRYPTING';
            
            // Disable buttons during encryption
            document.getElementById('encrypt-btn').disabled = true;
            document.getElementById('decrypt-btn').disabled = true;
            document.getElementById('download-btn').style.display = 'none';
            
            // Generate encryption key
            generateEncryptionKey();
            
            // Start visualizations
            window.encryptionVis.startEncryption();
            window.hexDisplay.start();
            
            // Update progress
            let progress = 0;
            const progressBar = document.getElementById('progress-bar');
            const progressPercent = document.getElementById('progress-percent');
            
            const progressInterval = setInterval(() => {
                progress += 1 + Math.random() * 2;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                    
                    // Complete encryption
                    setTimeout(finishEncryption, 500);
                }
                
                progressBar.style.width = `${progress}%`;
                progressPercent.textContent = `${Math.round(progress)}%`;
            }, 100);
            
            // Log to console
            const consoleOutput = document.getElementById('console-output');
            const logEntries = [
                '> Initializing encryption process',
                '> Generating secure AES-256 key',
                '> Creating initialization vector',
                '> Processing image data'
            ];
            
            logEntries.forEach((entry, index) => {
                setTimeout(() => {
                    const logEntry = document.createElement('div');
                    logEntry.textContent = entry;
                    consoleOutput.appendChild(logEntry);
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }, index * 500);
            });
        }
        
        function finishEncryption() {
            window.isEncrypting = false;
            
            // Create "encrypted" image from original
            if (window.originalImage) {
                // Here we're just pretending to encrypt by creating a copy
                // In a real app, you'd actually perform encryption
                window.encryptedImage = window.originalImage;
                window.processedImageType = 'encrypted';
                
                // Update preview with "encrypted" effect
                const imagePreview = document.getElementById('image-preview');
                imagePreview.innerHTML = '';
                
                const canvas = document.createElement('canvas');
                canvas.width = window.originalImage.width;
                canvas.height = window.originalImage.height;
                const ctx = canvas.getContext('2d');
                
                // Draw with pixelation effect to simulate encryption
                ctx.drawImage(window.originalImage, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply visual "encryption" effect
                for (let i = 0; i < data.length; i += 4) {
                    // Randomize pixels but preserve overall image structure
                    const noise = Math.floor(Math.random() * 100) - 50;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                    data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise)); // G
                    data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise)); // B
                    
                    // Add scan lines
                    if (i % (canvas.width * 16) < canvas.width * 4) {
                        data[i] = Math.min(255, data[i] + 30);
                        data[i+1] = Math.min(255, data[i+1] + 30);
                        data[i+2] = Math.min(255, data[i+2] + 30);
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Store the canvas for download
                window.processedImageCanvas = canvas;
                
                const preview = document.createElement('img');
                preview.src = canvas.toDataURL();
                preview.className = 'max-h-full max-w-full object-contain';
                imagePreview.appendChild(preview);
                
                // Add glitch overlay
                const overlay = document.createElement('div');
                overlay.className = 'glitch-overlay';
                imagePreview.appendChild(overlay);
            }
            
            // Update UI
            const status = document.getElementById('encryption-status');
            status.textContent = 'ENCRYPTION COMPLETE';
            status.className = 'text-sm text-green-500 mb-2';
            
            document.getElementById('system-status').textContent = 'ENCRYPTED';
            
            // Enable decrypt button
            document.getElementById('decrypt-btn').disabled = false;
            
            // Show download button
            document.getElementById('download-btn').style.display = 'block';
            
            // Stop visualizations
            window.encryptionVis.stopEncryption();
            window.hexDisplay.stop();
            
            // Log to console
            const consoleOutput = document.getElementById('console-output');
            const logEntry = document.createElement('div');
            logEntry.textContent = '> Encryption completed successfully';
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Trigger success animation
            triggerSuccessAnimation();
        }
        
        function startDecryption() {
            if (!window.encryptedImage) return;
            
            window.isEncrypting = true;
            
            // Update UI
            const status = document.getElementById('encryption-status');
            status.textContent = 'DECRYPTION IN PROGRESS';
            status.className = 'text-sm text-yellow-500 mb-2';
            
            document.getElementById('system-status').textContent = 'DECRYPTING';
            
            // Disable buttons during decryption
            document.getElementById('encrypt-btn').disabled = true;
            document.getElementById('decrypt-btn').disabled = true;
            document.getElementById('download-btn').style.display = 'none';
            
            // Start visualizations
            window.encryptionVis.startEncryption();
            window.hexDisplay.start();
            
            // Update progress
            let progress = 0;
            const progressBar = document.getElementById('progress-bar');
            const progressPercent = document.getElementById('progress-percent');
            
            const progressInterval = setInterval(() => {
                progress += 1 + Math.random() * 2;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                    
                    // Complete decryption
                    setTimeout(finishDecryption, 500);
                }
                
                progressBar.style.width = `${progress}%`;
                progressPercent.textContent = `${Math.round(progress)}%`;
            }, 100);
            
            // Log to console
            const consoleOutput = document.getElementById('console-output');
            const logEntries = [
                '> Initializing decryption process',
                '> Retrieving encryption key',
                '> Validating data integrity',
                '> Processing encrypted data'
            ];
            
            logEntries.forEach((entry, index) => {
                setTimeout(() => {
                    const logEntry = document.createElement('div');
                    logEntry.textContent = entry;
                    consoleOutput.appendChild(logEntry);
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }, index * 500);
            });
        }
        
        function finishDecryption() {
            window.isEncrypting = false;
            
            // Restore original image
            if (window.originalImage) {
                window.processedImageType = 'decrypted';
                
                // Create a canvas with the original image for download
                const canvas = document.createElement('canvas');
                canvas.width = window.originalImage.width;
                canvas.height = window.originalImage.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(window.originalImage, 0, 0);
                window.processedImageCanvas = canvas;
                
                const imagePreview = document.getElementById('image-preview');
                imagePreview.innerHTML = '';
                
                const preview = document.createElement('img');
                preview.src = window.originalImage.src;
                preview.className = 'max-h-full max-w-full object-contain';
                imagePreview.appendChild(preview);
                
                // Add glitch overlay
                const overlay = document.createElement('div');
                overlay.className = 'glitch-overlay';
                imagePreview.appendChild(overlay);
            }
            
            // Update UI
            const status = document.getElementById('encryption-status');
            status.textContent = 'DECRYPTION COMPLETE';
            status.className = 'text-sm text-green-500 mb-2';
            
            document.getElementById('system-status').textContent = 'DECRYPTED';
            
            // Enable encrypt button
            document.getElementById('encrypt-btn').disabled = false;
            
            // Show download button
            document.getElementById('download-btn').style.display = 'block';
            
            // Stop visualizations
            window.encryptionVis.stopEncryption();
            window.hexDisplay.stop();
            
            // Log to console
            const consoleOutput = document.getElementById('console-output');
            const logEntry = document.createElement('div');
            logEntry.textContent = '> Decryption completed successfully';
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Trigger success animation
            triggerSuccessAnimation();
        }
        
        // Download image functionality
        function downloadProcessedImage() {
            if (!window.processedImageCanvas) return;
            
            const link = document.createElement('a');
            
            // Get original filename and add suffix
            const originalName = window.currentImageName || 'image';
            const nameParts = originalName.split('.');
            const extension = nameParts.length > 1 ? nameParts.pop() : 'png';
            const baseName = nameParts.join('.');
            const suffix = window.processedImageType === 'encrypted' ? '-encrypted' : '-decrypted';
            const fileName = `${baseName}${suffix}.${extension}`;
            
            // Create download link
            link.download = fileName;
            link.href = window.processedImageCanvas.toDataURL('image/png');
            link.click();
            
            // Log to console
            const consoleOutput = document.getElementById('console-output');
            const logEntry = document.createElement('div');
            logEntry.textContent = `> Image saved as: ${fileName}`;
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Flash success animation
            triggerSuccessAnimation();
        }
        
        // Success animation
        function triggerSuccessAnimation() {
            const successAnim = document.getElementById('success-animation');
            successAnim.classList.add('active');
            
            setTimeout(() => {
                successAnim.classList.remove('active');
            }, 800);
        }
        
        // Initialize all components
        document.addEventListener('DOMContentLoaded', () => {
            setupMatrixRain();
            setupNetworkVisualization();
            setupEncryptionVisualization();
            setupDataVisualization();
            initHexDisplay();
            setupConsole();
            setupResourceMonitoring();
            setupImageHandling();
        });
    </script>
</body>
</html>
